---
sidebar_position: 9
---

# Логирование и обработка ошибок

## Логирование

Рассмотрим ситуацию, в которой мы бы не заботились о логировании на протяжении всей работы над проектом. Успешно его завершили, протестировали и отдали заказчику.
Спустя какое-то время, как приложением начали пользоваться юзеры, получаем сообщение от заказчика, что пользователи жалуются на то, что у них без какой-либо системы крашится приложение.

Мы начинаем искать ошибки и причины краша приложения. Все, что нам о них известно - что они происходят на нескольких экранах без какой-либо системы.  
Попробовали воспроизвести ошибки - не получилось. Проверили код нескольких проблемных экранов - тоже вроде бы все в порядке, проблемные места обработаны.  
Остается последний вариант - пробовать воспроизводить ошибки, чтобы определить в каком месте и по какой причине они происходят. Всей командой пытаемся добиться креша приложения, но у нас все работает, ни одного креша за целый день.
Наконец, спустя еще N времени кому-нибудь удалось достичь креша, и исправили силами одного разработчика за 30 минут.  

Согласитесь - бороться таким образом с каждой ошибкой не самый хороший вариант. 

Чтобы избежать этого, мы используем сервис [Firebase Crashlytics](https://firebase.google.com/docs/crashlytics), который позволяет получать данные обо всех ошибках, которые произошли у юзеров на устройствах, без какого либо участия с их стороны.  
Сервис позволяет ловить два вида ошибок:
  - `fatal` - произошел прям краш приложения
  - `non-fatal` - произошла ошибка, однако, она была как-то обработана (`try catch`)

Как реагировать на с `fatal` и `non-fatal` ошибки:
- fatal:
  - раз приложение крашнулось, значит где-то произошла ошибка, которая никак не обрабатывается. Наши действия: добавим обработчик ошибкок в то место, где она произошла, добавим логирование средствами в `Firebase Crashlytics`, чтобы все следующие ошибки в этом месте попадали в `Firebase`, но уже как `non-fatal`
- non-fatal:
  - раз произошла `non-fatal` ошибка, значит проблемное место мы уже обрабатываем и логируем
  
Рассмотри `non-fatal` ошибки подробнее:
Какими они бывают:
  - это новая ошибка, которая произошла из-за косяка в нашем коде
  - это стандартная ошибка, например, из-за отсутствия интернета, или нехватки памяти на устройстве, чтобы сохранить файл

Если ошибка произошла из-за какого-то недочета в коде - мы просто исправим код и все.  

Если же эта ошибка стандартная - мы изменим условие логирования, чтобы больше не видеть информацию об этой ошибке в `Firebase`. Это поможет нам избавиться от информации о куче `non-fatal` ошибок, и, когда произойдет какая-то новая ошибка, мы сразу это заметим и пойдем разбираться, а не пропустим ее в общей куче ошибок.

Теперь, когда нам снова напишет заказчик и сообщит, что у юзеров опять крашится приложение, наш план будет следующим:
- открываем `Firebase Crashlytics`, видим, какая ошибка происходит у пользователей
- оперативно исправляем ошибку

Для логирования в общем коде мы используем библиотеку [Napier](https://github.com/AAkira/Napier), которую связываем с `FirebaseCrashlytics`, чтобы логируя используя `Napier`, логи автоматически попадали и в `Firebase`.

Поэтому, при разработке нового проекта логи проставляются как минимум во всех обработчиках ошибок.

Также, если заранее удается понять, что какая-то информация каждого конкретного запуска приложения может пригодиться для последующего исправления ошибки, ее также следует логировать с уровнем `INFO`. Однако, никакие секретные ключи и пароли логировать нельзя.


## Обработка ошибок в общем коде

В любом мобильном приложении часто происходят не фатальные ошибки, направленные на обратную связь, например: отсутствие интернет соединения, нехватка памяти на устройстве для загрузки данных, различные ответы сервера и т.д. Обо всем этом нужно корректно доносить пользователю.  
Такие ошибки, как правило, показываются юзеру как аллерт или тост, чтобы юзер успел посмотреть, в чем проблема и попробовал решить ее самостоятельно. 

Мы в IceRock используем для этого библиотеку [moko-errors](https://github.com/icerockdev/moko-errors).  
С ее помощью мы можем:
- централизованно обрабатывать все ошибки общего кода
- выбрать, как показывать ошибку юзеру `Toast`, `Alert`
- Использовать разные строки для разных ошибок, прямо в общем коде

Разберем компоненты этой библиотеки:

`ExceptionMappersStorage` - в нем мы регистрируем всю логику, как из `Exception` получить текстовое описание проблемы, чтобы во всей логике, во всех фичах не задумываться о том, какой текст выдать для каждой ошибки вызывать маппер, который вернет нужную строку.
Имеет возможность установки текста:
- для конкретной ошибки
- для всех ошибок, удовлетворяющих какому-нибудь условию
- текст по умолчанию - "Неизвестная ошибка", уже задан в проекте-шаблоне

Если вы знаете, какие ошибки могут произойти в вашем приложении - регистрируйте их в маппере 

## Практическое задание

- склонируйте себе moko-errors
- запустите sample, посмотрите как работает на обеих платформах
- добавьте `alertErrorPresenter`, настройте, проверьте как работает 
- добавьте свой класс ошибки, по аналогии с `CustomException`, добавьте свою строку локализации для отображения информации об этой ошибке, убедитесь что все работает на обеих платформах
- склонируйте себе mobile-moko-bolirplate, посмотрите как создается `ExceptionMappersStorage`, функция `createExceptionHandler`, как прокидывается до вьюмодели 
